"""
PostgreSQL test/question/answer management helpers.
Provides CRUD operations for quiz/test generation.
"""

import os
import logging
from typing import Optional, List, Dict, Tuple
from dataclasses import dataclass
from datetime import datetime
import psycopg2
from psycopg2.extras import RealDictCursor

logger = logging.getLogger(__name__)

# PostgreSQL schema for test/question/answer tables
POSTGRES_TEST_SCHEMA = [
    """CREATE TABLE IF NOT EXISTS test (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name TEXT NOT NULL,
        version INTEGER DEFAULT 1,
        created_at TIMESTAMPTZ NOT NULL DEFAULT now()
    )""",
    """CREATE INDEX IF NOT EXISTS idx_test_name ON test(name)""",
    """CREATE INDEX IF NOT EXISTS idx_test_version ON test(version)""",
    """CREATE INDEX IF NOT EXISTS idx_test_name_version ON test(name, version)""",
    """CREATE TABLE IF NOT EXISTS question (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        test_id BIGINT NOT NULL REFERENCES test(id) ON DELETE CASCADE,
        prompt TEXT NOT NULL,
        explanation TEXT,
        level TEXT DEFAULT 'a1',
        flags INTEGER DEFAULT 0,
        UNIQUE (test_id, prompt)
    )""",
    """CREATE INDEX IF NOT EXISTS idx_question_test_id ON question(test_id)""",
    """CREATE INDEX IF NOT EXISTS idx_question_level ON question(level)""",
    """CREATE INDEX IF NOT EXISTS idx_question_test_id_level ON question(test_id, level)""",
    """CREATE TABLE IF NOT EXISTS answer (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        question_id BIGINT NOT NULL REFERENCES question(id) ON DELETE CASCADE,
        body_uuid TEXT NOT NULL,
        is_correct BOOLEAN NOT NULL,
        weight REAL DEFAULT 1.0,
        UNIQUE (question_id, body_uuid)
    )""",
    """CREATE INDEX IF NOT EXISTS idx_answer_question_id ON answer(question_id)""",
    """CREATE INDEX IF NOT EXISTS idx_answer_body_uuid ON answer(body_uuid)""",
    """CREATE INDEX IF NOT EXISTS idx_answer_question_id_correct ON answer(question_id) WHERE is_correct = true""",
    """CREATE INDEX IF NOT EXISTS idx_answer_question_id_incorrect ON answer(question_id) WHERE is_correct = false"""
]


@dataclass
class Test:
    """Represents a test/quiz."""
    id: int
    name: str
    version: int
    created_at: datetime


@dataclass
class Question:
    """Represents a test question."""
    id: int
    test_id: int
    prompt: str
    explanation: Optional[str]
    level: str
    flags: int


@dataclass
class Answer:
    """Represents a possible answer to a question."""
    id: int
    question_id: int
    body_uuid: str
    is_correct: bool
    weight: float


class PostgresTestDatabase:
    """PostgreSQL database interface for test/question/answer management."""
    
    def __init__(self, connection_string: Optional[str] = None):
        """
        Initialize database connection.
        
        Args:
            connection_string: PostgreSQL connection string. If None, uses POSTGRES_CONNECTION env var.
        """
        self.connection_string = connection_string or os.getenv("POSTGRES_CONNECTION")
        if not self.connection_string:
            raise ValueError("No PostgreSQL connection string provided")
        
        self.conn = None
        self._connect()
    
    def _connect(self):
        """Establish database connection."""
        try:
            self.conn = psycopg2.connect(self.connection_string)
            self.conn.autocommit = False
            logger.info("Connected to PostgreSQL test database")
            # Ensure schema exists
            self._ensure_schema()
        except Exception as e:
            logger.error(f"Failed to connect to PostgreSQL: {e}")
            raise
    
    def _ensure_schema(self):
        """Ensure all test/question/answer tables exist."""
        try:
            with self.conn.cursor() as cursor:
                for stmt in POSTGRES_TEST_SCHEMA:
                    cursor.execute(stmt)
                
                # Grant permissions to current user
                cursor.execute("SELECT current_user")
                current_user = cursor.fetchone()[0]
                
                # Grant all privileges on tables
                cursor.execute(f"GRANT ALL PRIVILEGES ON TABLE test TO {current_user}")
                cursor.execute(f"GRANT ALL PRIVILEGES ON TABLE question TO {current_user}")
                cursor.execute(f"GRANT ALL PRIVILEGES ON TABLE answer TO {current_user}")
                
                # Grant usage on sequences
                cursor.execute(f"GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO {current_user}")
                
                self.conn.commit()
            logger.info("Test schema initialized with permissions granted")
        except Exception as e:
            logger.error(f"Failed to initialize test schema: {e}")
            self.conn.rollback()
            raise
    
    def close(self):
        """Close database connection."""
        if self.conn:
            self.conn.close()
            logger.info("Closed PostgreSQL connection")
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            self.conn.rollback()
        self.close()
    
    # ===== Test CRUD =====
    
    def create_test(self, name: str, version: int = 1) -> int:
        """
        Create a new test.
        
        Args:
            name: Test name
            version: Test version number
            
        Returns:
            Test ID
        """
        with self.conn.cursor() as cursor:
            cursor.execute(
                "INSERT INTO test (name, version) VALUES (%s, %s) RETURNING id",
                (name, version)
            )
            test_id = cursor.fetchone()[0]
            self.conn.commit()
            logger.info(f"Created test: {name} (id={test_id}, version={version})")
            return test_id
    
    def get_test(self, test_id: int) -> Optional[Test]:
        """
        Get a test by ID.
        
        Args:
            test_id: Test ID
            
        Returns:
            Test object or None if not found
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, name, version, created_at FROM test WHERE id = %s",
                (test_id,)
            )
            row = cursor.fetchone()
            if row:
                return Test(**row)
            return None
    
    def get_test_by_name(self, name: str, version: Optional[int] = None) -> Optional[Test]:
        """
        Get a test by name and optional version.
        
        Args:
            name: Test name
            version: Test version (if None, returns latest version)
            
        Returns:
            Test object or None if not found
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            if version is not None:
                cursor.execute(
                    "SELECT id, name, version, created_at FROM test WHERE name = %s AND version = %s",
                    (name, version)
                )
            else:
                cursor.execute(
                    "SELECT id, name, version, created_at FROM test WHERE name = %s ORDER BY version DESC LIMIT 1",
                    (name,)
                )
            row = cursor.fetchone()
            if row:
                return Test(**row)
            return None
    
    def get_all_tests(self) -> List[Test]:
        """
        Get all tests.
        
        Returns:
            List of Test objects
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, name, version, created_at FROM test ORDER BY created_at DESC"
            )
            return [Test(**row) for row in cursor.fetchall()]
    
    def update_test(self, test_id: int, name: Optional[str] = None, version: Optional[int] = None) -> bool:
        """
        Update test properties.
        
        Args:
            test_id: Test ID
            name: New name (optional)
            version: New version (optional)
            
        Returns:
            True if updated, False if test not found
        """
        updates = []
        params = []
        
        if name is not None:
            updates.append("name = %s")
            params.append(name)
        if version is not None:
            updates.append("version = %s")
            params.append(version)
        
        if not updates:
            return True
        
        params.append(test_id)
        
        with self.conn.cursor() as cursor:
            cursor.execute(
                f"UPDATE test SET {', '.join(updates)} WHERE id = %s",
                params
            )
            success = cursor.rowcount > 0
            self.conn.commit()
            return success
    
    def delete_test(self, test_id: int) -> bool:
        """
        Delete a test (cascade deletes questions and answers).
        
        Args:
            test_id: Test ID
            
        Returns:
            True if deleted, False if not found
        """
        with self.conn.cursor() as cursor:
            cursor.execute("DELETE FROM test WHERE id = %s", (test_id,))
            success = cursor.rowcount > 0
            self.conn.commit()
            if success:
                logger.info(f"Deleted test {test_id}")
            return success
    
    # ===== Question CRUD =====
    
    def create_question(
        self,
        test_id: int,
        prompt: str,
        explanation: Optional[str] = None,
        level: str = "a1",
        flags: int = 0
    ) -> int:
        """
        Create a new question for a test.
        
        Args:
            test_id: Test ID
            prompt: Question prompt text
            explanation: Optional explanation
            level: Question level (a1, a2, b1, b2, c1, c2)
            flags: Question flags
            
        Returns:
            Question ID
        """
        with self.conn.cursor() as cursor:
            cursor.execute(
                "INSERT INTO question (test_id, prompt, explanation, level, flags) VALUES (%s, %s, %s, %s, %s) RETURNING id",
                (test_id, prompt, explanation, level, flags)
            )
            question_id = cursor.fetchone()[0]
            self.conn.commit()
            logger.info(f"Created question {question_id} for test {test_id}")
            return question_id
    
    def get_question(self, question_id: int) -> Optional[Question]:
        """
        Get a question by ID.
        
        Args:
            question_id: Question ID
            
        Returns:
            Question object or None if not found
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, test_id, prompt, explanation, level, flags FROM question WHERE id = %s",
                (question_id,)
            )
            row = cursor.fetchone()
            if row:
                return Question(**row)
            return None
    
    def get_questions_for_test(self, test_id: int) -> List[Question]:
        """
        Get all questions for a test.
        
        Args:
            test_id: Test ID
            
        Returns:
            List of Question objects
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, test_id, prompt, explanation, level, flags FROM question WHERE test_id = %s ORDER BY id",
                (test_id,)
            )
            return [Question(**row) for row in cursor.fetchall()]
    
    def update_question(
        self,
        question_id: int,
        prompt: Optional[str] = None,
        explanation: Optional[str] = None,
        flags: Optional[int] = None
    ) -> bool:
        """
        Update question properties.
        
        Args:
            question_id: Question ID
            prompt: New prompt (optional)
            explanation: New explanation (optional)
            flags: New flags (optional)
            
        Returns:
            True if updated, False if question not found
        """
        updates = []
        params = []
        
        if prompt is not None:
            updates.append("prompt = %s")
            params.append(prompt)
        if explanation is not None:
            updates.append("explanation = %s")
            params.append(explanation)
        if flags is not None:
            updates.append("flags = %s")
            params.append(flags)
        
        if not updates:
            return True
        
        params.append(question_id)
        
        with self.conn.cursor() as cursor:
            cursor.execute(
                f"UPDATE question SET {', '.join(updates)} WHERE id = %s",
                params
            )
            success = cursor.rowcount > 0
            self.conn.commit()
            return success
    
    def delete_question(self, question_id: int) -> bool:
        """
        Delete a question (cascade deletes answers).
        
        Args:
            question_id: Question ID
            
        Returns:
            True if deleted, False if not found
        """
        
        with self.conn.cursor() as cursor:
            cursor.execute("DELETE FROM question WHERE id = %s", (question_id,))
            success = cursor.rowcount > 0
            self.conn.commit()
            if success:
                logger.info(f"Deleted question {question_id}")
            return success
    
    # ===== Answer CRUD =====
    
    def create_answer(
        self,
        question_id: int,
        body_uuid: str,
        is_correct: bool,
        weight: float = 1.0
    ) -> int:
        """
        Create a new answer for a question.
        
        Args:
            question_id: Question ID
            body_uuid: UUID of the word for this answer
            is_correct: Whether this is a correct answer
            weight: Answer weight for scoring
            
        Returns:
            Answer ID
        """
        with self.conn.cursor() as cursor:
            cursor.execute(
                "INSERT INTO answer (question_id, body_uuid, is_correct, weight) VALUES (%s, %s, %s, %s) RETURNING id",
                (question_id, body_uuid, is_correct, weight)
            )
            answer_id = cursor.fetchone()[0]
            self.conn.commit()
            logger.info(f"Created answer {answer_id} for question {question_id}")
            return answer_id
    
    def get_answer(self, answer_id: int) -> Optional[Answer]:
        """
        Get an answer by ID.
        
        Args:
            answer_id: Answer ID
            
        Returns:
            Answer object or None if not found
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, question_id, body_uuid, is_correct, weight FROM answer WHERE id = %s",
                (answer_id,)
            )
            row = cursor.fetchone()
            if row:
                return Answer(**row)
            return None
    
    def get_answers_for_question(self, question_id: int) -> List[Answer]:
        """
        Get all answers for a question.
        
        Args:
            question_id: Question ID
            
        Returns:
            List of Answer objects
        """
        with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
            cursor.execute(
                "SELECT id, question_id, body_uuid, is_correct, weight FROM answer WHERE question_id = %s ORDER BY id",
                (question_id,)
            )
            return [Answer(**row) for row in cursor.fetchall()]
    
    def update_answer(
        self,
        answer_id: int,
        body_uuid: Optional[str] = None,
        is_correct: Optional[bool] = None,
        weight: Optional[float] = None
    ) -> bool:
        """
        Update answer properties.
        
        Args:
            answer_id: Answer ID
            body_uuid: New word UUID for this answer (optional)
            is_correct: New correctness flag (optional)
            weight: New weight (optional)
            
        Returns:
            True if updated, False if answer not found
        """
        updates = []
        params = []
        
        if body_uuid is not None:
            updates.append("body_uuid = %s")
            params.append(body_uuid)
        if is_correct is not None:
            updates.append("is_correct = %s")
            params.append(is_correct)
        if weight is not None:
            updates.append("weight = %s")
            params.append(weight)
        
        if not updates:
            return True
        
        params.append(answer_id)
        
        with self.conn.cursor() as cursor:
            cursor.execute(
                f"UPDATE answer SET {', '.join(updates)} WHERE id = %s",
                params
            )
            success = cursor.rowcount > 0
            self.conn.commit()
            return success
    
    def delete_answer(self, answer_id: int) -> bool:
        """
        Delete an answer.
        
        Args:
            answer_id: Answer ID
            
        Returns:
            True if deleted, False if not found
        """
        with self.conn.cursor() as cursor:
            cursor.execute("DELETE FROM answer WHERE id = %s", (answer_id,))
            success = cursor.rowcount > 0
            self.conn.commit()
            if success:
                logger.info(f"Deleted answer {answer_id}")
            return success
    
    # ===== Composite Operations =====
    
    def create_question_with_answers(
        self,
        test_id: int,
        prompt: str,
        answers: List[Tuple[str, bool, float]],
        explanation: Optional[str] = None,
        flags: int = 0
    ) -> Tuple[int, List[int]]:
        """
        Create a question with multiple answers in a single transaction.
        
        Args:
            test_id: Test ID
            prompt: Question prompt
            answers: List of (body_uuid, is_correct, weight) tuples
            explanation: Optional explanation
            flags: Question flags
            
        Returns:
            Tuple of (question_id, list of answer_ids)
        """
        question_id = self.create_question(test_id, prompt, explanation, flags)
        answer_ids = []
        
        for body_uuid, is_correct, weight in answers:
            answer_id = self.create_answer(question_id, body_uuid, is_correct, weight)
            answer_ids.append(answer_id)
        
        logger.info(f"Created question {question_id} with {len(answer_ids)} answers")
        return question_id, answer_ids
    
    def get_test_with_questions_and_answers(self, test_id: int) -> Optional[Dict]:
        """
        Get a complete test with all questions and answers.
        
        Args:
            test_id: Test ID
            
        Returns:
            Dict with test, questions, and answers or None if test not found
        """
        test = self.get_test(test_id)
        if not test:
            return None
        
        questions = self.get_questions_for_test(test_id)
        
        result = {
            "test": test,
            "questions": []
        }
        
        for question in questions:
            answers = self.get_answers_for_question(question.id)
            result["questions"].append({
                "question": question,
                "answers": answers
            })
        
        return result
    
    def get_test_stats(self, test_id: int) -> Optional[Dict]:
        """
        Get statistics for a test.
        
        Args:
            test_id: Test ID
            
        Returns:
            Dict with question count, answer count, etc. or None if test not found
        """
        test = self.get_test(test_id)
        if not test:
            return None
        
        with self.conn.cursor() as cursor:
            # Count questions
            cursor.execute("SELECT COUNT(*) FROM question WHERE test_id = %s", (test_id,))
            question_count = cursor.fetchone()[0]
            
            # Count total answers
            cursor.execute(
                "SELECT COUNT(*) FROM answer a JOIN question q ON a.question_id = q.id WHERE q.test_id = %s",
                (test_id,)
            )
            answer_count = cursor.fetchone()[0]
            
            # Count correct answers
            cursor.execute(
                "SELECT COUNT(*) FROM answer a JOIN question q ON a.question_id = q.id WHERE q.test_id = %s AND a.is_correct = true",
                (test_id,)
            )
            correct_answer_count = cursor.fetchone()[0]
        
        return {
            "test_id": test_id,
            "test_name": test.name,
            "version": test.version,
            "question_count": question_count,
            "answer_count": answer_count,
            "correct_answer_count": correct_answer_count,
            "created_at": test.created_at
        }
